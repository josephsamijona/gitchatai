/**
 * Test Logging Utility for SYNAPSE AI Platform
 * Created by: Joseph Samuel Jonathan
 * Date: 2024-08-26 14:32:18
 */

import fs from 'fs';
import path from 'path';

export interface TestResult {
  testName: string;
  status: 'PASSED' | 'FAILED' | 'SKIPPED';
  duration: number;
  error?: string;
  details?: any;
  timestamp: Date;
}

export interface TestSuite {
  suiteName: string;
  startTime: Date;
  endTime?: Date;
  totalTests: number;
  passed: number;
  failed: number;
  skipped: number;
  results: TestResult[];
  logs: string[];
}

export class TestLogger {
  private suites: Map<string, TestSuite> = new Map();
  private currentSuite: string | null = null;
  private logBuffer: string[] = [];

  constructor(private outputDir: string = 'test-reports') {
    this.ensureOutputDir();
  }

  /**
   * Start a new test suite
   */
  startSuite(suiteName: string): void {
    const suite: TestSuite = {
      suiteName,
      startTime: new Date(),
      totalTests: 0,
      passed: 0,
      failed: 0,
      skipped: 0,
      results: [],
      logs: []
    };

    this.suites.set(suiteName, suite);
    this.currentSuite = suiteName;
    this.log(`🧪 Started test suite: ${suiteName}`);
  }

  /**
   * End current test suite
   */
  endSuite(): void {
    if (!this.currentSuite) return;

    const suite = this.suites.get(this.currentSuite);
    if (suite) {
      suite.endTime = new Date();
      suite.logs = [...this.logBuffer];
      this.log(`✅ Completed test suite: ${this.currentSuite}`);
      this.log(`📊 Results: ${suite.passed} passed, ${suite.failed} failed, ${suite.skipped} skipped`);
    }
    
    this.currentSuite = null;
    this.logBuffer = [];
  }

  /**
   * Log a test result
   */
  logTest(result: TestResult): void {
    if (!this.currentSuite) return;

    const suite = this.suites.get(this.currentSuite);
    if (suite) {
      suite.results.push(result);
      suite.totalTests++;

      switch (result.status) {
        case 'PASSED':
          suite.passed++;
          this.log(`✅ ${result.testName} - PASSED (${result.duration}ms)`);
          break;
        case 'FAILED':
          suite.failed++;
          this.log(`❌ ${result.testName} - FAILED (${result.duration}ms): ${result.error}`);
          break;
        case 'SKIPPED':
          suite.skipped++;
          this.log(`⏭️  ${result.testName} - SKIPPED`);
          break;
      }

      if (result.details) {
        this.log(`   Details: ${JSON.stringify(result.details, null, 2)}`);
      }
    }
  }

  /**
   * Add a log message
   */
  log(message: string): void {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    
    console.log(logMessage);
    this.logBuffer.push(logMessage);

    if (this.currentSuite) {
      const suite = this.suites.get(this.currentSuite);
      if (suite) {
        suite.logs.push(logMessage);
      }
    }
  }

  /**
   * Generate comprehensive test report
   */
  generateReport(): string {
    const timestamp = new Date();
    const formattedDate = timestamp.toISOString().replace(/[:.]/g, '-');
    
    let report = `# SYNAPSE AI Platform Test Report
## Generated by: Joseph Samuel Jonathan
## Date: ${timestamp.toLocaleString()}
## Environment: ${process.env.NODE_ENV || 'development'}

---

## Executive Summary

`;

    let totalTests = 0;
    let totalPassed = 0;
    let totalFailed = 0;
    let totalSkipped = 0;
    let totalDuration = 0;

    for (const suite of this.suites.values()) {
      totalTests += suite.totalTests;
      totalPassed += suite.passed;
      totalFailed += suite.failed;
      totalSkipped += suite.skipped;
      
      if (suite.startTime && suite.endTime) {
        totalDuration += suite.endTime.getTime() - suite.startTime.getTime();
      }
    }

    const successRate = totalTests > 0 ? (totalPassed / totalTests * 100).toFixed(2) : '0';

    report += `- **Total Test Suites**: ${this.suites.size}
- **Total Tests**: ${totalTests}
- **Passed**: ${totalPassed} ✅
- **Failed**: ${totalFailed} ❌
- **Skipped**: ${totalSkipped} ⏭️
- **Success Rate**: ${successRate}%
- **Total Duration**: ${totalDuration}ms

---

## Test Suite Details

`;

    for (const suite of this.suites.values()) {
      const duration = suite.startTime && suite.endTime 
        ? suite.endTime.getTime() - suite.startTime.getTime()
        : 0;

      const suiteSuccessRate = suite.totalTests > 0 
        ? (suite.passed / suite.totalTests * 100).toFixed(2) 
        : '0';

      report += `### 🧪 ${suite.suiteName}

**Duration**: ${duration}ms  
**Success Rate**: ${suiteSuccessRate}%  
**Tests**: ${suite.passed} passed, ${suite.failed} failed, ${suite.skipped} skipped

#### Test Results:
`;

      for (const result of suite.results) {
        const icon = result.status === 'PASSED' ? '✅' : result.status === 'FAILED' ? '❌' : '⏭️';
        report += `- ${icon} **${result.testName}** (${result.duration}ms)\n`;
        
        if (result.error) {
          report += `  - Error: \`${result.error}\`\n`;
        }
        
        if (result.details) {
          report += `  - Details: \`${JSON.stringify(result.details)}\`\n`;
        }
      }

      report += `\n#### Logs:
\`\`\`
${suite.logs.join('\n')}
\`\`\`

---

`;
    }

    // Environment information
    report += `## Environment Information

- **Node.js Version**: ${process.version}
- **Platform**: ${process.platform}
- **Architecture**: ${process.arch}
- **TiDB Host**: ${process.env.TIDB_HOST || 'Not configured'}
- **TiDB Database**: ${process.env.TIDB_DATABASE || 'Not configured'}
- **Redis URL**: ${process.env.REDIS_URL ? 'Configured' : 'Not configured'}
- **OpenAI API Key**: ${process.env.OPENAI_API_KEY ? 'Configured' : 'Not configured'}
- **Anthropic API Key**: ${process.env.ANTHROPIC_API_KEY ? 'Configured' : 'Not configured'}
- **Gemini API Key**: ${process.env.GEMINI_API_KEY ? 'Configured' : 'Not configured'}

---

## Performance Metrics

`;

    // Add performance analysis
    if (totalTests > 0) {
      const avgTestDuration = totalDuration / totalTests;
      report += `- **Average Test Duration**: ${avgTestDuration.toFixed(2)}ms
- **Slowest Test**: ${this.getSlowestTest()}
- **Fastest Test**: ${this.getFastestTest()}
`;
    }

    report += `
---

*Report generated at: ${timestamp.toISOString()}*
*Test execution completed by: Joseph Samuel Jonathan*
`;

    // Save report to file
    const filename = `test-report-${formattedDate}.md`;
    const filepath = path.join(this.outputDir, filename);
    
    try {
      fs.writeFileSync(filepath, report);
      this.log(`📄 Test report saved to: ${filepath}`);
    } catch (error) {
      this.log(`❌ Failed to save test report: ${error}`);
    }

    return report;
  }

  /**
   * Save detailed JSON report
   */
  saveJsonReport(): string {
    const timestamp = new Date();
    const formattedDate = timestamp.toISOString().replace(/[:.]/g, '-');
    
    const jsonReport = {
      metadata: {
        generatedBy: 'Joseph Samuel Jonathan',
        generatedAt: timestamp.toISOString(),
        environment: process.env.NODE_ENV || 'development',
        nodeVersion: process.version,
        platform: process.platform
      },
      summary: this.getSummary(),
      suites: Array.from(this.suites.values()),
      environment: this.getEnvironmentInfo()
    };

    const filename = `test-report-${formattedDate}.json`;
    const filepath = path.join(this.outputDir, filename);

    try {
      fs.writeFileSync(filepath, JSON.stringify(jsonReport, null, 2));
      this.log(`📄 JSON test report saved to: ${filepath}`);
      return filepath;
    } catch (error) {
      this.log(`❌ Failed to save JSON test report: ${error}`);
      return '';
    }
  }

  private ensureOutputDir(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  private getSummary() {
    let totalTests = 0;
    let totalPassed = 0;
    let totalFailed = 0;
    let totalSkipped = 0;

    for (const suite of this.suites.values()) {
      totalTests += suite.totalTests;
      totalPassed += suite.passed;
      totalFailed += suite.failed;
      totalSkipped += suite.skipped;
    }

    return {
      totalSuites: this.suites.size,
      totalTests,
      totalPassed,
      totalFailed,
      totalSkipped,
      successRate: totalTests > 0 ? (totalPassed / totalTests * 100) : 0
    };
  }

  private getEnvironmentInfo() {
    return {
      tidbConfigured: !!process.env.TIDB_HOST,
      redisConfigured: !!process.env.REDIS_URL,
      openaiConfigured: !!process.env.OPENAI_API_KEY,
      anthropicConfigured: !!process.env.ANTHROPIC_API_KEY,
      geminiConfigured: !!process.env.GEMINI_API_KEY,
      kimiConfigured: !!process.env.KIMI_API_KEY,
      grokConfigured: !!process.env.GROK_API_KEY
    };
  }

  private getSlowestTest(): string {
    let slowest: TestResult | null = null;
    
    for (const suite of this.suites.values()) {
      for (const result of suite.results) {
        if (!slowest || result.duration > slowest.duration) {
          slowest = result;
        }
      }
    }

    return slowest ? `${slowest.testName} (${slowest.duration}ms)` : 'N/A';
  }

  private getFastestTest(): string {
    let fastest: TestResult | null = null;
    
    for (const suite of this.suites.values()) {
      for (const result of suite.results) {
        if (!fastest || result.duration < fastest.duration) {
          fastest = result;
        }
      }
    }

    return fastest ? `${fastest.testName} (${fastest.duration}ms)` : 'N/A';
  }
}

export default TestLogger;